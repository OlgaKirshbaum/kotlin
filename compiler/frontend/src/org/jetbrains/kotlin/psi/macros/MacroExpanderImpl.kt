/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.psi.macros

import org.jetbrains.kotlin.psi.KtAnnotationEntry
import org.jetbrains.kotlin.resolve.BindingTrace
import org.jetbrains.kotlin.resolve.constants.evaluate.ConstantExpressionEvaluator
import org.jetbrains.kotlin.types.TypeUtils
import org.jetbrains.kotlin.diagnostics.Errors.MACRO_DEFINITION_NOT_FOUND
import org.jetbrains.kotlin.diagnostics.Errors.MACRO_ANNOTATION_NO_MATCHING_CONSTRUCTOR
import org.jetbrains.kotlin.diagnostics.Errors.MACRO_ANNOTATION_METHOD_INVOKE_NOT_FOUND
import org.jetbrains.kotlin.diagnostics.Errors.MACRO_ANNOTATION_ERROR
import org.jetbrains.kotlin.psi.KtClassOrObject
import org.jetbrains.kotlin.psi.KtReplaceable
import java.lang.IllegalArgumentException
import java.lang.reflect.InvocationTargetException
import java.lang.reflect.Method
import java.net.URL
import java.net.URLClassLoader
import kotlin.meta.MutableVisitor
import kotlin.meta.Node

class MacroExpanderImpl(
    private val trace: BindingTrace,
    private val constantExpressionEvaluator: ConstantExpressionEvaluator,
    dependencies: Collection<String>
) : MacroExpander {
    private val urls: Array<URL> = dependencies
        .map { URL("file:///$it") }
        .toTypedArray()
    private var gensymCounter: Int = 0

    override fun run(annotationEntry: KtAnnotationEntry, node: Node): Node? {
        try {
            val name = annotationEntry.fullName() ?: return null
            val classLoader = URLClassLoader(urls, this::class.java.classLoader)
            val klass = classLoader.loadClass(name)
            val args = annotationEntry.valueArguments
                .map {
                    val constant = it.getArgumentExpression()
                        ?.let { e -> constantExpressionEvaluator.evaluateToConstantValue(e, trace, TypeUtils.NO_EXPECTED_TYPE) }
                    constant?.value
                }
                .toTypedArray()
            val instance = klass.declaredConstructors.single().apply { isAccessible = true }.newInstance(*args)
            val invokeMethod = findProperInvokeMethod(annotationEntry, klass.declaredMethods).apply { isAccessible = true }
            val result = invokeMethod.invoke(instance, node) as Node
            return postprocess(annotationEntry, result)
        } catch (e: Exception) {
            trace.report(
                (when (e) {
                    is ClassNotFoundException -> MACRO_DEFINITION_NOT_FOUND
                    is IllegalArgumentException, is NoSuchElementException, is InstantiationException ->
                        MACRO_ANNOTATION_NO_MATCHING_CONSTRUCTOR
                    is NoSuchMethodException -> MACRO_ANNOTATION_METHOD_INVOKE_NOT_FOUND
                    is InvocationTargetException -> MACRO_ANNOTATION_ERROR
                    else -> throw e
                }).on(annotationEntry)
            )
        }
        return null
    }

    private fun postprocess(annotationEntry: KtAnnotationEntry, node: Node): Node {
        val visited = mutableMapOf<Node, Node>()
        return MutableVisitor.postVisit(node) { v, _ ->
            if (v is Node.Expr.Name && v.isAutoGenerated && !v.isExternal) {
                if (visited.containsKey(v)) visited[v]
                else v.copy(value = "${v.value}_${annotationEntry.parent.hashCode()}_${gensymCounter++}").also { visited[v] = it }
            } else v
        }
    }

    private fun findProperInvokeMethod(annotationEntry: KtAnnotationEntry, methods: Array<Method>): Method {
        val annotatedElementClass = annotationEntry.annotatedElement().toNodeClass()
        fun Method.singleParameterType() = parameterTypes.single()
        val candidates = methods.filter {
            it.isMacroFunction() && it.singleParameterType().isAssignableFrom(annotatedElementClass)
        }.toMutableList()
        if (candidates.isEmpty()) throw NoSuchMethodException()
        while (candidates.size > 1) {
            val first = candidates[0].singleParameterType()
            val second = candidates[1].singleParameterType()
            candidates.removeAt(if (first.isAssignableFrom(second)) 0 else 1)
        }
        return candidates.single()
    }

    private fun Method.isMacroFunction() = name == "invoke"
            && Node::class.java.isAssignableFrom(returnType)
            && parameterCount == 1 && Node::class.java.isAssignableFrom(parameterTypes.single())

    private fun KtAnnotationEntry.fullName(): String? {
        val imports = (containingKtFile.importList?.imports ?: return shortName?.identifier).filter {
            it.importedFqName?.pathSegments()?.last() == shortName
        }
        return when {
            imports.isEmpty() -> shortName?.identifier
            imports.size == 1 -> imports.single().importedFqName?.asString()
            else -> null
        }
    }

    private fun KtAnnotationEntry.annotatedElement(): KtReplaceable {
        var annotated = parent
        while (annotated !is KtReplaceable) {
            annotated = annotated.parent
        }
        return annotated
    }

    private fun KtReplaceable.toNodeClass() = when (this) {
        is KtClassOrObject -> Node.Decl.Structured::class
        else -> Node::class
    }.java
}